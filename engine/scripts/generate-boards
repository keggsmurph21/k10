#!/usr/bin/env python3

from collections import Counter
from collections import defaultdict

import os
import sys


class Position:
    def __init__(self, num, dx, dy):
        self.num = num
        self.dx = dx
        self.dy = dy

    def __repr__(self):
        return f"Clock{self.num}"

    def __eq__(self, other):
        return self.num == other.num and self.dx == other.dx and self.dy == other.dy

    def __hash__(self):
        return hash((self.num, self.dx, self.dy))

    def __str__(self):
        return f"Direction::Clock{self.num}"


class Node:
    char = None

    def __init__(self, num, x, y):
        self.num = num
        self.x = x
        self.y = y
        self.neighbors = {
            Position(12, -3, 0): None,
            Position(2, -1, 4): None,
            Position(4, 1, 4): None,
            Position(6, 3, 0): None,
            Position(8, 1, -4): None,
            Position(10, -1, -4): None,
        }

    def __iter__(self):
        for pos, neighbor in self.neighbors.items():
            if neighbor is not None:
                yield (pos, neighbor)

    def __len__(self):
        return len([_ for _ in self])

    def __repr__(self):
        return f"{self.char} #{self.num} ({self.x},{self.y})"


class Whitespace(Node):
    char = " "


class Ocean(Node):
    char = "o"


class Hex(Node):
    char = "h"


class UnflippedHex(Node):
    char = "?"


class Junction(Node):
    char = "."

    def __init__(self, num, x, y):
        super().__init__(num, x, y)
        self.neighbors.update(
            {
                Position(12, -1, 0): None,
                Position(6, 1, 0): None,
                Position(2, -1, 2): None,
                Position(8, 1, -2): None,
                Position(4, 1, 2): None,
                Position(10, -1, -2): None,
            }
        )


class Port(Junction):
    char = "p"

    def __init__(self, num, x, y):
        super().__init__(num, x, y)
        self.partner = None
        self.pos = None

    def set_partner(self, position, partner):
        assert isinstance(partner, Port)
        assert self.partner is None
        self.partner = partner
        self.pos = str(position)
        if partner.partner is not None:
            assert partner.partner == self


class Road(Node):
    def __init__(self, num, x, y, orientation):
        super().__init__(num, x, y)
        self.char = self.orientation = orientation
        if self.orientation == "|":
            self.neighbors = {
                Position(12, -1, 0): None,
                Position(6, 1, 0): None,
            }
        elif self.orientation == "/":
            self.neighbors = {
                Position(2, -1, 2): None,
                Position(8, 1, -2): None,
            }
        elif self.orientation == "\\":
            self.neighbors = {
                Position(4, 1, 2): None,
                Position(10, -1, -2): None,
            }


class Board:
    def __init__(self, name, src_dir, tar_dir):

        self.name = name
        self.board_file = os.path.join(src_dir, name + ".board")
        self.cpp_file = os.path.join(tar_dir, name + ".h")

        self.junctions = []
        self.roads = []
        self.hexes = []
        self.unflipped_hexes = []
        self.oceans = []
        self.ports = []

        with open(self.board_file) as fp:

            # initialize arr
            self.height = 0
            self.width = 0
            for line in fp:
                self.height += 1
                self.width = max(self.width, len(line))
            self.arr = [
                [Whitespace(-1, i, j) for j in range(self.width)]
                for i in range(self.height)
            ]

            # lex
            fp.seek(0)
            num = 0
            for x, line in enumerate(fp):
                for y, ch in enumerate(line):
                    if ch in (" ", "\n"):
                        continue
                    elif ch == ".":
                        token = Junction(num, x, y)
                        self.junctions.append(token)
                    elif ch == "p":
                        token = Port(num, x, y)
                        self.junctions.append(token)
                        self.ports.append(token)
                    elif ch == "o":
                        token = Ocean(num, x, y)
                        self.oceans.append(token)
                    elif ch == "h":
                        token = Hex(num, x, y)
                        self.hexes.append(token)
                    elif ch == "?":
                        token = UnflippedHex(num, x, y)
                        self.unflipped_hexes.append(token)
                    elif ch in ("|", "/", "\\"):
                        token = Road(num, x, y, ch)
                        self.roads.append(token)
                    else:
                        assert False
                    self.arr[token.x][token.y] = token
                    num += 1

        """
        # check lexing
        assert len(self.junctions) == 54
        assert len(self.roads) == 72
        assert len(self.hexes) == 19
        assert len(self.unflipped_hexes) == 0
        assert len(self.oceans) == 18
        """

        # parse
        for token_list in [
            self.roads,
            self.junctions,
            self.hexes,
            self.unflipped_hexes,
            self.oceans,
        ]:
            for token in token_list:
                for pos in token.neighbors:
                    off_x = token.x + pos.dx
                    if off_x < 0 or self.height <= off_x:
                        continue
                    off_y = token.y + pos.dy
                    if off_y < 0 or self.width <= off_y:
                        continue
                    neighbor = self.arr[off_x][off_y]
                    if isinstance(neighbor, Whitespace):
                        continue
                    token.neighbors[pos] = neighbor
                    if (
                        isinstance(token, Port)
                        and isinstance(neighbor, Road)
                        and isinstance(neighbor.neighbors[pos], Port)
                    ):
                        token.set_partner(pos, neighbor.neighbors[pos])

        """
        # check parsing
        for token in self.roads:
            assert len(token) == 2
        for token in self.junctions:
            assert len(token) in (5, 6)
        for token in self.hexes:
            assert len(token) == 6
        for token in self.unflipped_hexes:
            assert len(token) == 0
        for token in self.oceans:
            assert len(token) in (2, 3)
        """

    def generate_cpp(self):
        with open(self.cpp_file, "w") as fp:
            fp.write(
                f"""\
#pragma once

#include "Board/Base.h"

/**
 * DO NOT EDIT THIS FILE DIRECTLY.
 *
 * It was generated automatically from running
 *   $ {__file__} {self.name}
 */
namespace k10engine {{

namespace Board {{

Base* get_{self.name.lower()}_board()
{{
    return new Base("{self.name}", new Graph({{ """
            )
            for road in self.roads:
                fp.write(f"{{ {road.num}, NodeType::Road }}, ")
            for junction in self.junctions:
                fp.write(f"{{ {junction.num}, NodeType::Junction }}, ")
            for hex_ in self.hexes:
                fp.write(f"{{ {hex_.num}, NodeType::Hex }}, ")
            for ocean in self.oceans:
                fp.write(f"{{ {ocean.num}, NodeType::Ocean }}, ")
            for unflipped_hex in self.unflipped_hexes:
                fp.write(f"{{ {unflipped_hex.num}, NodeType::UnflippedHex }}, ")
            fp.write(f"}}, {{")
            for road in self.roads:
                for pos, neighbor in road:
                    fp.write(f"{{ {road.num}, {neighbor.num}, {pos} }}, ")
            for junction in self.junctions:
                for pos, neighbor in junction:
                    fp.write(f"{{ {junction.num}, {neighbor.num}, {pos} }}, ")
            for hex_ in self.hexes:
                for pos, neighbor in hex_:
                    fp.write(f"{{ {hex_.num}, {neighbor.num}, {pos} }}, ")
            for ocean in self.oceans:
                for pos, neighbor in ocean:
                    fp.write(f"{{ {ocean.num}, {neighbor.num}, {pos} }}, ")
            for unflipped_hex in self.unflipped_hexes:
                for pos, neighbor in unflipped_hex:
                    fp.write(f"{{ {unflipped_hex.num}, {neighbor.num}, {pos} }}, ")
            fp.write(f"""}}), {{ """)
            for port in self.ports:
                if port.num < port.partner.num:
                    fp.write(
                        f"{{ {port.num}, {port.partner.num}, get_orientation({port.pos}) }}, "
                    )
            fp.write(
                f"""}});

}}

}} // namespace Board

}} // namespace k10engine
"""
            )
            print(f"Wrote file to {os.path.realpath(self.cpp_file)}", file=sys.stderr)


if __name__ == "__main__":

    from argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument("--names", nargs="*")
    args = parser.parse_args()

    src_dir = os.path.join(os.path.dirname(__file__), "..", "static", "boards")
    tar_dir = os.path.join(
        os.path.dirname(__file__), "..", "include", "Board", "generated"
    )

    if len(args.names):
        for name in args.names:
            b = Board(name, src_dir, tar_dir)
            b.generate_cpp()
    else:
        for f in os.listdir(src_dir):
            if f.endswith(".board"):
                name, _ = os.path.splitext(f)
                b = Board(name, src_dir, tar_dir)
                b.generate_cpp()
