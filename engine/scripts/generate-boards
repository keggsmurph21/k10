#!/usr/bin/env python3

from collections import Counter
from collections import defaultdict

import os
import sys


class Position:
    def __init__(self, num, dx, dy):
        self.num = num
        self.dx = dx
        self.dy = dy

    def __repr__(self):
        return f"Clock{self.num}"

    def __eq__(self, other):
        return self.num == other.num and self.dx == other.dx and self.dy == other.dy

    def __hash__(self):
        return hash((self.num, self.dx, self.dy))

    def generate_cpp(self):
        return f"Direction::Clock{self.num}"


class Node:
    char = None

    def __init__(self, num, x, y):
        self.num = num
        self.x = x
        self.y = y
        self.neighbors = {
            Position(12, -3, 0): None,
            Position(2, -1, 4): None,
            Position(4, 1, 4): None,
            Position(6, 3, 0): None,
            Position(8, 1, -4): None,
            Position(10, -1, -4): None,
        }

    def __iter__(self):
        for pos, neighbor in self.neighbors.items():
            if neighbor is not None:
                yield (pos, neighbor)

    def __len__(self):
        return len([_ for _ in self])

    def __repr__(self):
        return f"{self.char} #{self.num} ({self.x},{self.y})"


class Whitespace(Node):
    char = " "


class Ocean(Node):
    char = "o"

    def generate_cpp(self):
        for pos, neighbor in self:
            yield f"m_graph->ocean({self.num})->add_edge({pos.generate_cpp()}, m_graph->junction({neighbor.num}));"


class Hex(Node):
    char = "h"

    def generate_cpp(self):
        for pos, neighbor in self:
            yield f"m_graph->hex({self.num})->add_edge({pos.generate_cpp()}, m_graph->junction({neighbor.num}));"


class Flippable(Node):
    char = "?"

    def generate_cpp(self):
        for pos, neighbor in self:
            yield f"m_graph->flippable({self.num})->add_edge({pos.generate_cpp()}, m_graph->junction({neighbor.num}));"


class Junction(Node):
    char = "."

    def __init__(self, num, x, y):
        super().__init__(num, x, y)
        self.neighbors.update(
            {
                Position(12, -1, 0): None,
                Position(6, 1, 0): None,
                Position(2, -1, 2): None,
                Position(8, 1, -2): None,
                Position(4, 1, 2): None,
                Position(10, -1, -2): None,
            }
        )

    def generate_cpp(self):
        for pos, neighbor in self:
            if isinstance(neighbor, Ocean):
                yield f"m_graph->junction({self.num})->add_edge({pos.generate_cpp()}, m_graph->ocean({neighbor.num}));"
            elif isinstance(neighbor, Hex):
                yield f"m_graph->junction({self.num})->add_edge({pos.generate_cpp()}, m_graph->hex({neighbor.num}));"
            elif isinstance(neighbor, Flippable):
                yield f"m_graph->junction({self.num})->add_edge({pos.generate_cpp()}, m_graph->flippable({neighbor.num}));"
            elif isinstance(neighbor, Road):
                yield f"m_graph->junction({self.num})->add_edge({pos.generate_cpp()}, m_graph->road({neighbor.num}));"


class Port(Junction):
    char = "p"

    def __init__(self, num, x, y):
        super().__init__(num, x, y)
        self.partner = None
        self.direction = None

    def set_partner(self, position, partner):
        assert isinstance(partner, Port)
        assert self.partner is None
        self.partner = partner
        self.direction = str(position)
        if partner.partner is not None:
            assert partner.partner == self

    def generate_cpp(self):
        yield from super().generate_cpp()
        yield (
            f"m_graph->junction({self.num})->set_port("
            f"get_orientation(Direction::{self.direction}), "
            f"m_graph->junction({self.partner.num}));"
        )


class Road(Node):
    def __init__(self, num, x, y, orientation):
        super().__init__(num, x, y)
        self.char = self.orientation = orientation
        if self.orientation == "|":
            self.neighbors = {
                Position(12, -1, 0): None,
                Position(6, 1, 0): None,
            }
        elif self.orientation == "/":
            self.neighbors = {
                Position(2, -1, 2): None,
                Position(8, 1, -2): None,
            }
        elif self.orientation == "\\":
            self.neighbors = {
                Position(4, 1, 2): None,
                Position(10, -1, -2): None,
            }

    def generate_cpp(self):
        for pos, neighbor in self:
            yield f"m_graph->road({self.num})->add_edge({pos.generate_cpp()}, m_graph->junction({neighbor.num}));"


class Board:
    def __init__(self, name, src_dir, tar_dir):

        self.name = name
        self.board_file = os.path.join(src_dir, name + ".board")
        self.cpp_file = os.path.join(tar_dir, name + "Board.h")

        self.junctions = []
        self.roads = []
        self.hexes = []
        self.flippables = []
        self.oceans = []

        with open(self.board_file) as fp:

            # initialize arr
            self.height = 0
            self.width = 0
            for line in fp:
                self.height += 1
                self.width = max(self.width, len(line))
            self.arr = [
                [Whitespace(-1, i, j) for j in range(self.width)]
                for i in range(self.height)
            ]

            # lex
            fp.seek(0)
            for x, line in enumerate(fp):
                for y, ch in enumerate(line):
                    if ch in (" ", "\n"):
                        continue
                    elif ch == ".":
                        token = Junction(len(self.junctions), x, y)
                        self.junctions.append(token)
                    elif ch == "p":
                        token = Port(len(self.junctions), x, y)
                        self.junctions.append(token)
                    elif ch == "o":
                        token = Ocean(len(self.oceans), x, y)
                        self.oceans.append(token)
                    elif ch == "h":
                        token = Hex(len(self.hexes), x, y)
                        self.hexes.append(token)
                    elif ch == "?":
                        token = Flippable(len(self.flippables), x, y)
                        self.flippables.append(token)
                    elif ch in ("|", "/", "\\"):
                        token = Road(len(self.roads), x, y, ch)
                        self.roads.append(token)
                    else:
                        assert False
                    self.arr[token.x][token.y] = token

        """
        # check lexing
        assert len(self.junctions) == 54
        assert len(self.roads) == 72
        assert len(self.hexes) == 19
        assert len(self.flippables) == 0
        assert len(self.oceans) == 18
        """

        # parse
        for token_list in [
            self.roads,
            self.junctions,
            self.hexes,
            self.flippables,
            self.oceans,
        ]:
            for token in token_list:
                for pos in token.neighbors:
                    off_x = token.x + pos.dx
                    if off_x < 0 or self.height <= off_x:
                        continue
                    off_y = token.y + pos.dy
                    if off_y < 0 or self.width <= off_y:
                        continue
                    neighbor = self.arr[off_x][off_y]
                    if isinstance(neighbor, Whitespace):
                        continue
                    token.neighbors[pos] = neighbor
                    if (
                        isinstance(token, Port)
                        and isinstance(neighbor, Road)
                        and isinstance(neighbor.neighbors[pos], Port)
                    ):
                        token.set_partner(pos, neighbor.neighbors[pos])

        """
        # check parsing
        for token in self.roads:
            assert len(token) == 2
        for token in self.junctions:
            assert len(token) in (5, 6)
        for token in self.hexes:
            assert len(token) == 6
        for token in self.flippables:
            assert len(token) == 0
        for token in self.oceans:
            assert len(token) in (2, 3)
        """

    def generate_cpp(self):
        with open(self.cpp_file, "w") as fp:
            fp.write(
                """\
#pragma once

#include "Board/Base.h"
#include "Board/Graph.h"

/**
 * DO NOT EDIT THIS FILE DIRECTLY.
 *
 * It was generated automatically from running
 *   $ {filename} {name}
 */
namespace k10engine {{

namespace Board {{

class {name}Board : public Base {{
public:
    {name}Board()
    {{
        m_name = "{name}";
        m_graph = new Graph(
            {n_roads}, // roads
            {n_junctions}, // junctions
            {n_hexes}, // hexes
            {n_flippables}, // flippables
            {n_oceans} // oceans
        );
""".format(
                    filename=__file__,
                    name=self.name,
                    n_roads=len(self.roads),
                    n_hexes=len(self.hexes),
                    n_junctions=len(self.junctions),
                    n_flippables=len(self.flippables),
                    n_oceans=len(self.oceans),
                )
            )
            for road in self.roads:
                for cpp_line in road.generate_cpp():
                    fp.write("        {line}\n".format(line=cpp_line))
            for junction in self.junctions:
                for cpp_line in junction.generate_cpp():
                    fp.write("        {line}\n".format(line=cpp_line))
            for hex_ in self.hexes:
                for cpp_line in hex_.generate_cpp():
                    fp.write("        {line}\n".format(line=cpp_line))
            for flippable in self.flippables:
                for cpp_line in flippable.generate_cpp():
                    fp.write("        {line}\n".format(line=cpp_line))
            for ocean in self.oceans:
                for cpp_line in ocean.generate_cpp():
                    fp.write("        {line}\n".format(line=cpp_line))
            fp.write(
                """
    }

    std::string name() {
        return m_name;
    }

private:
    Graph* m_graph;
    std::string m_name;
};

} // namespace Board

} // namespace k10engine
"""
            )
            print(f"Wrote file to {os.path.realpath(self.cpp_file)}", file=sys.stderr)


if __name__ == "__main__":

    from argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument("--names", nargs="*")
    args = parser.parse_args()

    src_dir = os.path.join(os.path.dirname(__file__), "..", "static", "boards")
    tar_dir = os.path.join(
        os.path.dirname(__file__), "..", "include", "Board", "generated"
    )

    if len(args.names):
        for name in args.names:
            b = Board(name, src_dir, tar_dir)
            b.generate_cpp()
    else:
        for f in os.listdir(src_dir):
            if f.endswith(".board"):
                name, _ = os.path.splitext(f)
                b = Board(name, src_dir, tar_dir)
                b.generate_cpp()
