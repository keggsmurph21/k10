#!/usr/bin/env python3

from typing import Dict, Generator, List, Optional, Tuple

import os
import sys


class Position:
    def __init__(self, num: int, dx: int, dy: int):
        self.num = num
        self.dx = dx
        self.dy = dy

    def __repr__(self) -> str:
        return f"Clock{self.num}"

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Position)
            and self.num == other.num
            and self.dx == other.dx
            and self.dy == other.dy
        )

    def __hash__(self) -> int:
        return hash((self.num, self.dx, self.dy))

    def __str__(self) -> str:
        return f"Direction::Clock{self.num}"

    def opposite(self) -> "Position":
        return Position((self.num + 6) % 12 or 12, -self.dx, -self.dy)


class Node:
    char: str
    node_type: str

    def __init__(self, num: int, x: int, y: int):
        self.num = num
        self.x = x
        self.y = y
        self.neighbors: Dict[Position, Optional[Node]] = {
            Position(12, -3, 0): None,
            Position(2, -1, 4): None,
            Position(4, 1, 4): None,
            Position(6, 3, 0): None,
            Position(8, 1, -4): None,
            Position(10, -1, -4): None,
        }

    def __iter__(self) -> Generator[Tuple[Position, "Node"], None, None]:
        for pos, neighbor in self.neighbors.items():
            if neighbor is not None:
                yield (pos, neighbor)

    def __len__(self) -> int:
        return len([_ for _ in self])

    def __repr__(self) -> str:
        return f"{self.char} #{self.num} ({self.x},{self.y})"


class Whitespace(Node):
    char = " "


class Ocean(Node):
    char = "o"
    node_type = "Ocean"


class Hex(Node):
    char = "h"
    node_type = "Hex"


class UnflippedHex(Node):
    char = "?"
    node_type = "UnflippedHex"


class Junction(Node):
    char = "."
    node_type = "Junction"

    def __init__(self, num: int, x: int, y: int):
        super().__init__(num, x, y)
        self.neighbors.update(
            {
                Position(12, -1, 0): None,
                Position(6, 1, 0): None,
                Position(2, -1, 2): None,
                Position(8, 1, -2): None,
                Position(4, 1, 2): None,
                Position(10, -1, -2): None,
            }
        )


class Port(Junction):
    char = "p"
    node_type = "Junction"

    def __init__(self, num: int, x: int, y: int):
        super().__init__(num, x, y)
        self.partner: Optional["Port"] = None
        self.pos: Optional[str] = None

    def set_partner(self, position: Position, partner: "Port") -> None:
        assert self.partner is None
        self.partner = partner
        self.pos = str(position)
        if partner.partner is not None:
            assert partner.partner == self


class Road(Node):
    char = "r"
    node_type = "Road"

    def __init__(self, num: int, x: int, y: int, orientation: str):
        super().__init__(num, x, y)
        self.char = self.orientation = orientation
        if self.orientation == "|":
            self.neighbors = {
                Position(12, -1, 0): None,
                Position(6, 1, 0): None,
            }
        elif self.orientation == "/":
            self.neighbors = {
                Position(2, -1, 2): None,
                Position(8, 1, -2): None,
            }
        elif self.orientation == "\\":
            self.neighbors = {
                Position(4, 1, 2): None,
                Position(10, -1, -2): None,
            }


class Board:
    def __init__(self, name: str, src_dir: str, tar_dir: str):

        self.name = name
        self.board_file = os.path.join(src_dir, name + ".board")
        self.cpp_file = os.path.join(tar_dir, name + ".h")

        self.tokens: List[Node] = []
        self.ports: List[Port] = []

        with open(self.board_file) as fp:

            # initialize arr
            self.height = 0
            self.width = 0
            for line in fp:
                self.height += 1
                self.width = max(self.width, len(line))
            self.arr: List[List[Node]] = [
                [Whitespace(-1, i, j) for j in range(self.width)]
                for i in range(self.height)
            ]

            # lex
            fp.seek(0)
            num = 0
            for x, line in enumerate(fp):
                for y, ch in enumerate(line):
                    token: Node
                    if ch in (" ", "\n"):
                        continue
                    elif ch == ".":
                        token = Junction(num, x, y)
                        self.tokens.append(token)
                    elif ch == "p":
                        token = Port(num, x, y)
                        self.ports.append(token)
                        self.tokens.append(token)
                    elif ch == "o":
                        token = Ocean(num, x, y)
                        self.tokens.append(token)
                    elif ch == "h":
                        token = Hex(num, x, y)
                        self.tokens.append(token)
                    elif ch == "?":
                        token = UnflippedHex(num, x, y)
                        self.tokens.append(token)
                    elif ch in ("|", "/", "\\"):
                        token = Road(num, x, y, ch)
                        self.tokens.append(token)
                    else:
                        assert False
                    self.arr[token.x][token.y] = token
                    num += 1

        # parse
        for token in self.tokens:
            for pos in token.neighbors:
                off_x = token.x + pos.dx
                if off_x < 0 or self.height <= off_x:
                    continue
                off_y = token.y + pos.dy
                if off_y < 0 or self.width <= off_y:
                    continue
                neighbor = self.arr[off_x][off_y]
                if isinstance(neighbor, Whitespace):
                    continue
                token.neighbors[pos] = neighbor
                if (
                    isinstance(token, Port)
                    and isinstance(neighbor, Road)
                    and isinstance(neighbor.neighbors[pos], Port)
                ):
                    second_neighbor_in_direction = neighbor.neighbors[pos]
                    assert isinstance(second_neighbor_in_direction, Port)
                    token.set_partner(pos, second_neighbor_in_direction)
                    second_neighbor_in_direction.set_partner(pos.opposite(), token)

    def generate_cpp(self) -> None:
        with open(self.cpp_file, "w") as fp:
            fp.write(
                f"""\
#pragma once

#include "Board/Graph.h"

/**
 * DO NOT EDIT THIS FILE DIRECTLY.
 *
 * It was generated automatically from running
 *   $ {__file__} {self.name}
 */
namespace k10engine {{

namespace Board {{

Graph* get_{self.name.lower()}_board()
{{
    return new Graph({{ """
            )
            for token in self.tokens:
                fp.write(f"NodeType::{token.node_type}, ")
            fp.write(f"}}, {{")
            for token in self.tokens:
                for pos, neighbor in token:
                    fp.write(f"{{ {token.num}, {neighbor.num}, {pos} }}, ")
            fp.write(f"""}}, {{ """)
            for port in self.ports:
                assert port.partner is not None
                if port.num < port.partner.num:
                    fp.write(
                        f"{{ {port.num}, {port.partner.num}, get_orientation({port.pos}) }}, "
                    )
            fp.write(
                f"""}});

}}

}} // namespace Board

}} // namespace k10engine
"""
            )
            print(f"Wrote file to {os.path.realpath(self.cpp_file)}", file=sys.stderr)


if __name__ == "__main__":

    from argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument("--names", nargs="*")
    args = parser.parse_args()

    src_dir = os.path.join(os.path.dirname(__file__), "..", "static", "boards")
    tar_dir = os.path.join(
        os.path.dirname(__file__), "..", "include", "Board", "generated"
    )

    if len(args.names):
        for name in args.names:
            b = Board(name, src_dir, tar_dir)
            b.generate_cpp()
    else:
        for f in os.listdir(src_dir):
            if f.endswith(".board"):
                name, _ = os.path.splitext(f)
                b = Board(name, src_dir, tar_dir)
                b.generate_cpp()
